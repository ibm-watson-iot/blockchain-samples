# IoT Sample Contract

[`main.go`](../main.go "main file for the IoT sample contract")  

This document describes the main file in the [IoT Trade Lane Sample for Hyperledger](https://github.com/ibm-watson-iot/blockchain-samples/tree/master/trade_lane_contract_hyperledger), beginning with the contract's object model and moving on to the contract's API and key algorithms.

>*Read the [Introduction to Hyperledger Smart Contracts for IoT, Best Practices and Patterns](HyperledgerContractsIntroBestPracticesPatterns.md) and its specified pre-reading __before__ reading this and other detailed contract documents.*

## Contract Object Model

### Asset

Any smart contract derived from the IoT trade lane sample contract must have a primary area of focus. It is the `thing` on which the contract is focused. The thing could be a container or package, as in the trade lane contract, or it could be a vehicle, a refrigerator, an automobile part, and so on. 

The trade lane sample contract calls the *things* about which it cares **assets** and is therefore built around the identifier for those assets, the `assetID`.

> A reminder that the trade lane sample contract is written for IoT scenarios, where assets are identified and are the subject of periodic readings from **devices**, including bar code scanners, GPS locators, accelerometers, and so on. Composite devices may send readings containing several such properties. This was discussed in the referenced introductory article under the *Partial State as Event* pattern section. 

### Device

This contract does not have device identifiers in it, but it could. For example, every event is generated by a device or an application (which can and should be thought of as a *logical device* or a *device gateway* if it is sending readings or composite readings). A device will have a unique identifier if its message is sent through the IoT Platform. 

The key point about devices is that they send data about *things*, which we generically call *assets*. Thus, devices play a key role in the lifecycle of assets. 

> *The deviceID from which an event was generated would be saved automatically inside the `lastEvent` portion of the asset state so that lightweight analytics could be performed on devices using asset history.*

### Event

As mentioned earlier, the `event` object consists of the writable asset properties and its JSON encoding supports the partial state as event pattern. The following properties define an event:

#### `event` - Schema (output from getAssetSamples)

``` json

    "event": {
        "assetID": "The ID of a managed asset. The resource focal point for a smart contract.",
        "carrier": "transport entity currently in possession of asset",
        "extension": {},
        "location": {
            "latitude": 123.456,
            "longitude": 123.456
        },
        "temperature": 123.456,
        "timestamp": "2016-04-15T10:53:30.3964036-04:00"
    },

```

Properties used by trade lane:

* Mandatory for the contract to function at all
    * `assetID` - the ID of the asset that is the central focus of the contract, a good example being a container or package
* Useful in all IoT contracts 
    * `location` - a `Geolocation` object containing the properties `latitude` and `longitude` specifying the last known location of the object
    * `timestamp` - date and time that the event occured or state was created. 
    * `extension` - application-managed state as discussed elsewhere
* Specific to trade lane's lightweight shipping scenario
    * `temperature` - an asset-specific measurement of the temperature in Celsuis. This example contract uses zero as the threshold value, inclusive. That is, any temperature above zero is too high. The example is meant to simulate shipment of frozen goods. This is used to demonstrate how alerts work, so a temperature above zero raises an `OVERTEMP` alert, which would cause inspection of the contents on arrival and possible penalties to the responsible carrier.
    * `carrier` - the entity currently transporting the asset. Generally, a shipping company that is moving the asset between any combination of origin, way points and destination.

### State

The `event` is a subset of the asset's `state`. Thus state becomes event plus calculated (as in read-only) properties. These include `alerts`, `compliant`, and `lastEvent`.

#### `State` Schema (output from getAssetSamples)

The state object looks like:

``` json

    "state": {
        "alerts": {
            "active": [
                "OVERTTEMP"
            ],
            "cleared": [
                "OVERTTEMP"
            ],
            "raised": [
                "OVERTTEMP"
            ]
        },
        "assetID": "The ID of a managed asset. The resource focal point for a smart contract.",
        "carrier": "transport entity currently in possession of asset",
        "extension": {},
        "compliant": true,
        "lastEvent": {
            "args": [
                "parameters to the function, usually args[0] is populated with a JSON encoded event object"
            ],
            "function": "function that created this state object",
            "redirectedFromFunction": "function that originally received the event"
        },
        "location": {
            "latitude": 123.456,
            "longitude": 123.456
        },
        "temperature": 123.456,
        "timestamp": "2016-04-26T23:51:16.8214639-04:00"
    }

```

Read-only state properties additional to previously documented event properties:

* `alerts` - three arrays of alert name string from the `alertName` enum in the schema, of which only `OVERTEMP` is implemented in trade lane
    * `alerts.active` - alert names that are currently active
    * `alerts.raised` - alert names that were raised by this event, defining the exact moment of transition from clear to active
    * `alerts.cleared` - alert namess that were cleared by this event, defining the exact moment of transition from active to clear
* `compliant` - a boolean property specifying whether there are any active alerts for this asset
   * the trade lane sample contract defines *compliant* as *no alerts active*, but derived contracts can have much more complex algorithms
* `lastEvent` - the event that created this state
   * `function` - the function that handled the incoming event
   * `args` - the string args composing the incoming event, always one in this contract pattern
   * `redirectedFromFunction` - the function that redirected the event to the function that created this event

## Contract API

The contract's CRUD API that generically handles creation and update of assets without getting drawn into the minutia of many getters and setters. These generic flows allow the processing to separate into clearly identifiable chunks, mitigating complexity. That said, there are subtle differences between create and update that should be studied carefully before making changes. 

The documentation for the most complex functions will use annotated pseudo-code to separate the intent from the noise of the language and error handling. Consider following this document and the code in side by side windows in your favourite editor. Examples of excellent editors include VSCode, Sublime, Brackets and many others.

### Invokes (State Changing)

#### createAsset

Creates an asset that does not already exist, using `assetID` as the key. Attempting to create an existing asset will generate an error and fail. 

>*Note that there is one feature that can send a second parameter to `createAsset`. Redirected invokes to update non-existent assets are redirected from the `updateAsset` function by default. The name of the redirecting function is stuffed into `Args[1]` and saved in the `lastEvent` calculated property in the state.*

Following is an annotated pseudo-code description of `createAsset`:

``` go
// 1 arg, arg[0] is JSON partial state as event, optional arg[1] is redirecting function
fail if args < 1 or > 2
// next two lines create map that supports partial state as event
// note, since asset does not exist argsMap is also initial state
unmarshal args[0] as var event of type interface{}
assert event as type map[string]interface{} into var argsMap of type ArgsMap 
fail if assetID does not exist in args
fail if assetID is already in ledger
if timestamp does not exist
    insert one into argsMap using transaction time
// alerts removed from state if nothing is active, raised or cleared
// compliant removed if false 
run rules engine against argsMap to generate alerts
if any alert is active, raised or cleared
    add alerts to argsMap
    delete compliant from argsMap
else 
    delete alerts from argsMap
    add compliant=true to argsMap
copy argsMap to stateOut
// lastEvent is the event that specifically created this state
create lastEvent with function, event, and redirect if present
marshal stateOut to JSON
PUT state to ledger
add asset to activeAssets in contract state
create history bucket for asset and add state
push state change into recent states
```

#### updateAsset

Update assets that already exist. An assetID for a nonexistant asset will redirect to `createAsset` by default, or generate an error if the redirect feature is disabled using the `setCreateOnUpdate` API. 

The primary difference from a `createAsset` invocation is that `updateAsset` gets the existing asset state from the ledger and merges the incoming event with it to generate the new state. This is the cornerstone of the *partial state as event* pattern, since events carry data that are a subset of the writable properties of the state. Calculated fields are created after the deep merge has completed so that the entire state can be pushed into the rules engine and any other post processing that may exist in a derivation of trade lane.

Following is an annotated pseudo-code description of `updateAsset`:

``` go

// 1 arg, arg[0] is JSON partial state as event 
fail if number of args != 1
unmarshal args[0] as var event of type interface{}
assert event as type map[string]interface{} into var argsMap of type ArgsMap 
fail if assetID does not exist in args or is blank
if assetID is not in ledger
    redirect to createAsset if enabled
    else fail
if timestamp does not exist
    insert one into argsMap using transaction time
//args ready, process existing state from ledger    
GET asset state from ledger as assetBytes of type []byte
unmarshal assetBytes as ledgerBytes of type interface{} // bad name
assert ledgerBytes as type map[string]interface{} into var ledgerMap of type ArgsMap 
// deepMerge is a function in mapUtils.go
deep merge argsMap into ledgerMap and assign to stateOut
// alerts removed from state if nothing is active, raised or cleared
// compliant removed if false 
run rules engine against argsMap to generate alerts
if any alert is active, raised or cleared
    add alerts to argsMap
    delete compliant from argsMap
else 
    delete alerts from argsMap
    add compliant=true to argsMap
// lastEvent is the event that specifically created this state
create lastEvent with function, event, and redirect if present
marshal stateOut to JSON
PUT state to ledger
add state to history bucket for asset
push state change into recent states

```

#### deleteAsset

Delete an asset that already exists. Deleting a nonexistent returns an error. Asset state and history are permanently removed from the database. Asset is removed from recent states and from activeAssets in contract state. It ceases to exist except as transactions on the blockchain.

This function makes irreversible changes to World State. It should not be used in situations where historical data is used unless that data is backed up outside the blockchain. An alternative to deletion would be an asset status property that designates the asset as `idle` or `retired`. 

For example, a container sitting in storage after refurbishment might be allocated a new bar code, in which case the previous assetID could be deleted (permanent wipe) if the info is not needed for audit purposes or retired (logical deletion retaining history). 

``` go

// 1 arg, arg[0] is JSON partial state as event 
fail if number of args != 1
unmarshal args[0] as var event of type interface{}
assert event as type map[string]interface{} into var argsMap of type ArgsMap 
fail if assetID does not exist in args or is blank
fail if assetID is not in ledger
DELETE state from ledger
remove history bucket for asset
remove entry for asset if any from recent states

```

#### deletePropertiesFromAsset

>Unlike `deleteAsset`, this function does not change history, other than to add the new state to history. Removing properties is a semantic operation, and only to be performed when the properties are semantically incorrect with the asset's current status.

Removes specified properties from an asset. Processing in general is similar to updateAsset in that asset state (i.e. the ledger) is modified. But rather than deep merging during update, this function performs deep deletion.

Removing a property from a map is quite different from setting it to `zero` or `false` or `empty` in a struct. The absence of a property is semantically useful in that it indicates that the contract should no longer be concerned with it. Rules are designed to ignore missing properties, unless that is specifically what the rule is about. 

The `OVERTEMP` rule, for example, does not perform a calculation if the temperature is not present. And since the rules are run after state update, deleting temperature from the state has the same effect as receiving a compliant reading - any active alerts will clear. 

> Why might one remove the temperature property? 

> A container may have frozen goods removed at a way point before proceeding along its journey, causing the supervising application to realize that the container no longer contains frozen goods. There is therefore no longer a need to track the temperature, which effectively disables the `OVERTEMP` rule. Of course, if temperature readings are expected to continue with refrigeration is turned off, then new API would be needed to explicitly disable the rule or change the `OVERTEMP` threshold.

> Additionally, a more sophisticated contract might have a status property, where the transition from status delivered to status idle would remove all transient properties like temperature as they may or may not be relevant to the next shipment. The removal should only be performed after status has transitioned to `IDLE` because the compliance status is important in status `DELIVERED` in that inspections must have the opportunity to be performed if the contract has ever been out of compliance during the shipment.

``` go

// 1 arg, arg[0] is JSON partial state as event 
fail if number of args != 1
unmarshal args[0] as var event of type interface{}
assert event as type map[string]interface{} into var argsMap of type ArgsMap 
fail if assetID does not exist in args or is blank
fail if assetID is not in ledger
fail if qualified property names array is missing
    
//args are ready, now process existing state from ledger    
GET asset state from ledger as assetBytes of type []byte
unmarshal assetBytes as ledgerBytes of type interface{} // bad name
assert ledgerBytes as type map[string]interface{} into var ledgerMap of type ArgsMap 
// removal means splitting the qualified properties by level
// and removing the property from its submap. 
for all qualified properties to delete
    continue on next if deleting assetID or timeStamp 
    split qualified property by '.' into levels of type []string
    for all levels
        if this is the actual property (last level, leaf node)
            delete if propertyname exists
        else
            set context to new level if it exists

if timestamp does not exist
    insert one into argsMap using transaction time
// alerts removed from state if nothing is active, raised or cleared
// compliant removed if false 
run rules engine against argsMap to generate alerts
if any alert is active, raised or cleared
    add alerts to argsMap
    delete compliant from argsMap
else 
    delete alerts from argsMap
    add compliant=true to argsMap
// lastEvent is the event that specifically created this state
create lastEvent with function, event, and redirect if present
marshal stateOut to JSON
PUT state to ledger
add state to history bucket for asset
push state change into recent states

```

#### deleteAllAssets

Perform deleteAsset on every asset in the contract state's `activeAssets` array. The end result is that the ledger's state for this contract is empty.

### Queries (These do not Change State)

#### readAsset

Remember that state is stored as an encoded JSON object, i.e. a string. So if the assetID is present and non-blank and if the asset exists, then get the state from the ledger and return the string as is, cast to `[]byte` of course.

#### readAllAssets

Perform readAsset on every asset in the contract state's `activeAssets` array after sorting the `assetID` list. This makes it easy to search the list at the other end. Add each asset state to an array after unmarshaling. Once the array is completed, marshal the entire array and return to the client.

>*Warning: This API may not scale in applications with many active assets. Be aware of the costs and use at your own risk.*

#### readAssetHistory

Events received on behalf of an asset generate new asset states. Each new state is prepended to the asset's state history array, which is stored in reverse order with the most recent first. 

This function is intended to query the asset's history for purposes such as lightweight analytics, an example being plotting the temperature by date, time and location in order to assess penalties for spoilt goods.

If the assetID is present and non-blank and if the asset exists, then get the history state from the ledger and return the string as is cast to `[]byte`. Asset history uses a composite key made up of the `assetID` + `STATEHISTORYKEY`, which is defined as:

``` go

const STATEHISTORYKEY string = ".StateHistory"

```

Composite keys such as this are useful for storing additional data *about* assets.

> *Note that a future update to the state history module will introduce partitioning of the history data for better scaling. The partitioning will follow a key naming scheme that allows range iterators to select the appropriate buckets to process for any given timestamp range.*

#### readRecentStates

Every time an asset's state is changed, its new state is added to the contract's recent states array. It is placed at the beginning of the array so that the array is maintained in order by event arrival time, most recent first. This should be thought of as the *most recently created asset states across the entire contract*.

> *If an asset is already present in the recent states array, it is removed and the entries before its original position are shifted to close the gap. Its new state is then inserted into the array at the beginning as always. If it did not already exist, then the last one is dropped as the entire array is shifted to open a space for the new event.*

The returned recent states array is currently limited to 20 states. 

#### readAssetSamples

The schema processing script generates two Go files that can be read from the contract by applications through this and the following APIs. Samples are full JSON structures with every property populated with a value of the right type. These can be used to gain familiarity or to populate templates etc.
 
Returns the generated string `samples` that contains the samples that were configured to be generated when the contract was built. See the JSON configuration file in the `/scripts` folder.

#### readAssetSchemas

The payload schema contains the complete API and object model. The JSON configuration for the script generator creates a Go files with a string variable called `schemas` that can be parsed by applications such as the Watson IoT Platform and the generic UIs in this blockchain-samples project. 

> **All IoT contracts _must_ implement `readAssetSchemas` so that these applications can automatically integrate.**

Returns the generated string `schemas` that contains the schemas that were configured to be generated when the contract was built.

#### readContractState

Returns an object containing the contract's version number, its nickname, and the array of managed assets.

### Contract-Specific API

In addition to the asset's CRUD API, this trade lane sample contract has two functions to manage the contract's behavior. They use the prefix `set` instead of a CRUD prefix so that they stand apart from asset-oriented API.

#### setLoggingLevel

Change the logging level of a specific peer. The values are case-independent strings and legal values are `critical`, `error`, `warning`, `notice`, `info` and `debug`, matching exactly the levels in the go-logging package. 

The logging level changes immediately and stays at the set level until it is changed or the peer is restarted, in which case it comes up again at the default level. I.e. the new logging level is not persisted in World State.

> This setter is implemented as a transaction and so will affect all peers in a fabric. It will be reimplemented shortly as a query so that only one peer will see the setter. Since it does not attempt to persist in World State, a query is an acceptable mode for the transaction.

#### setCreateOnUpdate

Change the contract's redirect permission to allow or deny sending an update of an unknown asset to the `createAsset` function. The default is allow. 

