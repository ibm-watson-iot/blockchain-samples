/*
Copyright (c) 2016 IBM Corporation and other Contributors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and limitations under the License.

Contributors:
Kim Letkeman - Initial Contribution
Howard McKinney- Initial Contribution
*/

// IoT Blockchain Demo Smart Contract
// v1   KL 20 Jan 2016 Initial contract supporting multiple assets with temp and gforce
// v1.1 KL 25 Jan 2016 Fixed a few issues, added setState to allow arbitrary JSON arg, added contract state management
// v2   KL 29 Jan 2016 CRUD pattern, remove deleted tracking, added JSON object models
// v2.1 KL 01 Feb 2016 Add location
// v2.2 KL 02-03 Feb 2016 timestamp detection and adjustment, add structures for event tracking, general cleanup
// v2.3 KL 02-04 Feb 2016 return nil from deploy and invoke, []byte from query
// v2.4 KL 06-10 Feb 2016 bulk arg, add read all assets, replace event history prototype with state history
// v2.5 KL 10 Feb 2016 RFC3339 timestamps, add extension field, use maps instead of structs, add deleteAllAssets
// v2.6 KL 14 Feb 2016 add Carrier, add readAssetHistory() to isolate the use of history from contract state
// v2.7 KL 16 Feb 2016 new API readAssetHistory map of asset to ordered array latest first parameterized count
//                     new API readRecentStates ordered array latest first of any state change max 20
//                     recent states will never show more than the number of assets, as they must be unique
// v2.8 KL 17-21 Feb 2016 AlertStatus in separate file, rules engine in separate file
//                        separate the recent states to their own file
//                        align readAsset and readAllAssets output
// v2.9 KL 22 Feb 2016 inCompliance bool with addition to rules engine to handle it
//                     event string saving original arg for this state change
//                     delete readonly fields to avoid contamination of state, note that original event contains all sent fields
//                     renamed contract and folder to iot_blockchain_tradelane_beta_contract
// v3.0 HM 25 Feb 2016 Change where asset state history is stored -- store it in it's own bucket in the ledger.
//                     Moved the asset state history code into a separate package.
// v3.0.1 HM 03 Mar 2016 Store the state history in descending order.
// v3.0.2 KL 03 Mar 2016 Added a more complete sample object and a new API for the schema (generated by
//                       the new generator for 3.1). No impact on tests except for version change.
//                       also debuts the addition of readAssetEventSchema
// v3.0.3 KL 07 Mar 2016 production version with print statements suppressed
// v4.0 KL 09-10 Mar 2016 renumbered to 4.0 because the schema changes are API breaking
//                     remove state caching for contract state, recent states, separated contract state into module
//                     ripped out bulk interface as it is guaranteed to create state inconsistencies
//                     deepMerge for maps of incoming event and ledger state
//         11 Mar 2016 reversed inCompliance to noncompliant so that the normal compliant contract does not have
//                     any space taken up by the compliance section
// v3.0.4 KL 14-15 Mar 2016 backport statelessness from 4.0, logging from 4.0,
//                          remove bulk from 4.0, contractState module from 4.0
//                          cleaned up recenStates output, wrote new logging module
//           16 Mar 2016 fix alerts, merge example folder version with the hyperledger version (oops!),
//                       add nickname, clean up logging
// v3.0.5 KL 27 Mar 2016 add case insensitive JSON-RPC mode so that customers
//                       can choose how they want case handled on the wire
// v4.0   KL 15 April 2016 Adapt contract to Hyperledger. Change shim imports. Add Init function.
//                         Rename Run to Invoke. Change schema to add new /chaincode service end point etc.
//                         Remove state structs (use schema and mapUtils.) Make fixes based on lint, e.g. fmt.Errorf.
//                         Update all docs to reflect the changes.
// v4.1   KL May 27 2016 Store transaction UUID and timestamp in the state, aligning world state with the transaction
//                       (and by definition the block) that is responsible for this specific asset state. Note: Initial
//                       commit of this version was at 4.0 and was in the trade lane folder. Subsequently moved to the iot
//                       folder and updated to 4.1. Also:
//                         - Additional feature in 4.1 -- issue #4 -- rules engine must return err
//                         - Tweaks to deletePropertiesFromAsset (a bug found in the alert boilerplate using args instead of ledger)
//                         - Added postman tests for delete properties from asset and validation test rules
//                         - Reordered and normalized the rules engine call to make original event available and have consistency
//                           between create, update and delete properties.
// v4.2 KL May 28 2016 Replace all occurences of "incompliance" with "compliant" to remove an obvious source of confusion.
//                     Remove a copy paste error in the new testValidation rule where it was falling through and clearing
//                     the OVERTEMP rule, causing total havoc with that rule.
// v4.3 KL June 30 2016 Copied improvements from simple aviation contract 4.2sa. (1) Store the JSON map of the argument
//                      in the lastEvent. (2) Store TXNUUID and timestamp in state only. (3) Note position where setter
//                      subevents are deleted from state, while leaving recorder subevents intact. (4) Make deepcopy of
//                      args into stateOut in create to avoid infinite loop when args are attached into lastEvent.
// v4.4 KL 31 October 2016 Removed the dependency on contract state having a huge array of asset IDs. This was causing
//                         poor performance and instability on Bluemix with long term tests and many assets.

package main

import (
    "encoding/json"
    "errors"
    "fmt"
    "reflect"
    "sort"
    "strings"
    "time"

    "github.com/hyperledger/fabric/core/chaincode/shim"
)

//go:generate go run scripts/generate_go_schema.go

//***************************************************
//***************************************************
//* CONTRACT initialization and runtime engine
//***************************************************
//***************************************************

// ************************************
// definitions
// ************************************

// SimpleChaincode is the receiver for all shim API
type SimpleChaincode struct {
}

// ASSETID is the JSON tag for the assetID
const ASSETID string = "assetID"

// TIMESTAMP is the JSON tag for timestamps, devices must use this tag to be compatible!
const TIMESTAMP string = "timestamp"

// TXNTIMESTAMP is the JSON tag for transaction timestamps, which map directly onto the transaction in the blockchain
const TXNTIMESTAMP string = "txntimestamp"

// TXNUUID is the JSON tag for transaction UUIDs, which map directly onto the transaction in the blockchain
const TXNUUID string = "txnuuid"

// ArgsMap is a generic map[string]interface{} to be used as a receiver
type ArgsMap map[string]interface{}

var log = NewContractLogger(DEFAULTNICKNAME, DEFAULTLOGGINGLEVEL)

// ************************************
// start the message pumps
// ************************************
func main() {
    err := shim.Start(new(SimpleChaincode))
    if err != nil {
        log.Infof("ERROR starting Simple Chaincode: %s", err)
    }
}

// Init is called in deploy mode when contract is initialized
func (t *SimpleChaincode) Init(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
    var stateArg ContractState
    var err error

    log.Info("Entering INIT")

    if len(args) != 1 {
        err = errors.New("init expects one argument, a JSON string with  mandatory version and optional nickname")
        log.Critical(err)
        return nil, err
    }

    err = json.Unmarshal([]byte(args[0]), &stateArg)
    if err != nil {
        err = fmt.Errorf("Version argument unmarshal failed: %s", err)
        log.Critical(err)
        return nil, err
    }

    if stateArg.Nickname == "" {
        stateArg.Nickname = DEFAULTNICKNAME
    }

    (*log).setModule(stateArg.Nickname)

    err = initializeContractState(stub, stateArg.Version, stateArg.Nickname)
    if err != nil {
        return nil, err
    }

    log.Info("Contract initialized")
    return nil, nil
}

// Invoke is called in invoke mode to delegate state changing function messages
func (t *SimpleChaincode) Invoke(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
    if function == "createAsset" {
        return t.createAsset(stub, args)
    } else if function == "updateAsset" {
        return t.updateAsset(stub, args)
    } else if function == "deleteAsset" {
        return t.deleteAsset(stub, args)
    } else if function == "deleteAllAssets" {
        return t.deleteAllAssets(stub, args)
    } else if function == "deletePropertiesFromAsset" {
        return t.deletePropertiesFromAsset(stub, args)
    } else if function == "setLoggingLevel" {
        return nil, t.setLoggingLevel(stub, args)
    } else if function == "setCreateOnUpdate" {
        return nil, t.setCreateOnUpdate(stub, args)
    }
    err := fmt.Errorf("Invoke received unknown invocation: %s", function)
    log.Warning(err)
    return nil, err
}

// Query is called in query mode to delegate non-state-changing queries
func (t *SimpleChaincode) Query(stub shim.ChaincodeStubInterface, function string, args []string) ([]byte, error) {
    if function == "readAsset" {
        return t.readAsset(stub, args)
    } else if function == "readAllAssets" {
        return t.readAllAssets(stub, args)
    } else if function == "readRecentStates" {
        return readRecentStates(stub)
    } else if function == "readAssetHistory" {
        return t.readAssetHistory(stub, args)
    } else if function == "readAssetSamples" {
        return t.readAssetSamples(stub, args)
    } else if function == "readAssetSchemas" {
        return t.readAssetSchemas(stub, args)
    } else if function == "readContractObjectModel" {
        return t.readContractObjectModel(stub, args)
    } else if function == "readContractState" {
        return t.readContractState(stub, args)
    }
    err := fmt.Errorf("Query received unknown invocation: %s", function)
    log.Warning(err)
    return nil, err
}

//***************************************************
//***************************************************
//* ASSET CRUD INTERFACE
//***************************************************
//***************************************************

// ************************************
// createAsset
// ************************************
func (t *SimpleChaincode) createAsset(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var assetID string
    var argsMap ArgsMap
    var event interface{}
    var found bool
    var err error

    log.Info("Entering createAsset")

    // allowing 2 args because updateAsset is allowed to redirect when
    // asset does not exist
    if len(args) < 1 || len(args) > 2 {
        err = errors.New("Expecting one JSON event object")
        log.Error(err)
        return nil, err
    }

    assetID = ""
    eventBytes := []byte(args[0])
    log.Debugf("createAsset arg: %s", args[0])

    err = json.Unmarshal(eventBytes, &event)
    if err != nil {
        log.Errorf("createAsset failed to unmarshal arg: %s", err)
        return nil, err
    }

    if event == nil {
        err = errors.New("createAsset unmarshal arg created nil event")
        log.Error(err)
        return nil, err
    }

    argsMap, found = event.(map[string]interface{})
    if !found {
        err := errors.New("createAsset arg is not a map shape")
        log.Error(err)
        return nil, err
    }

    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string)
        if !found || assetID == "" {
            err := errors.New("createAsset arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }

    found = assetIsActive(stub, assetID)
    if found {
        err := fmt.Errorf("createAsset arg asset %s already exists", assetID)
        log.Error(err)
        return nil, err
    }

    // copy incoming event to outgoing state
    // this contract respects the fact that createAsset can accept a partial state
    // as the moral equivalent of one or more discrete events
    var stateOut ArgsMap
    stateOut = deepMerge(map[string]interface{}(argsMap),
        make(map[string]interface{}))

    // add transaction uuid and timestamp
    stateOut[TXNUUID] = stub.GetTxID()
    txnunixtime, err := stub.GetTxTimestamp()
    if err != nil {
        err = fmt.Errorf("Error getting transaction timestamp: %s", err)
        log.Error(err)
        return nil, err
    }
    txntimestamp := time.Unix(txnunixtime.Seconds, int64(txnunixtime.Nanos))
    stateOut[TXNTIMESTAMP] = txntimestamp

    // save the original event
    stateOut["lastEvent"] = make(map[string]interface{})
    stateOut["lastEvent"].(map[string]interface{})["function"] = "createAsset"
    stateOut["lastEvent"].(map[string]interface{})["arg"] = argsMap
    if len(args) == 2 {
        // in-band protocol for redirect
        stateOut["lastEvent"].(map[string]interface{})["redirectedFromFunction"] = args[1]
    }

    // run the rules and raise or clear alerts
    alerts := newAlertStatus()
    noncompliant, err := stateOut.executeRules(&alerts)
    if err != nil {
        err = fmt.Errorf("Rules engine failure: %s", err)
        log.Error(err)
        return nil, err
    }
    if noncompliant {
        log.Noticef("createAsset assetID %s is noncompliant", assetID)
        stateOut["alerts"] = alerts
        delete(stateOut, "compliant")
    } else {
        if alerts.AllClear() {
            // all false, no need to appear
            delete(stateOut, "alerts")
        } else {
            stateOut["alerts"] = alerts
        }
        stateOut["compliant"] = true
    }

    // remove setter or command sub-events now that the incoming event is captured
    //delete(stateOut, "setter1")
    //delete(stateOut, "setter2")

    // marshal to JSON and write
    stateJSON, err := json.Marshal(&stateOut)
    if err != nil {
        err := fmt.Errorf("createAsset state for assetID %s failed to marshal", assetID)
        log.Error(err)
        return nil, err
    }

    log.Debugf("CreateAsset: putting to state ==>%s<==", string(stateJSON))

    // finally, put the new state
    err = stub.PutState(assetID, []byte(stateJSON))
    if err != nil {
        err = fmt.Errorf("createAsset AssetID %s PUTSTATE failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    err = pushRecentState(stub, string(stateJSON))
    if err != nil {
        err = fmt.Errorf("createAsset AssetID %s push to recentstates failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    // save state history
    err = createStateHistory(stub, assetID, string(stateJSON))
    if err != nil {
        err := fmt.Errorf("createAsset asset %s state history save failed: %s", assetID, err)
        log.Critical(err)
        return nil, err
    }

    return nil, nil
}

// ************************************
// updateAsset
// ************************************
func (t *SimpleChaincode) updateAsset(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var assetID string
    var argsMap ArgsMap
    var event interface{}
    var ledgerMap ArgsMap
    var ledgerBytes interface{}
    var found bool
    var err error

    log.Info("Entering updateAsset")

    if len(args) != 1 {
        err = errors.New("Expecting one JSON event object")
        log.Error(err)
        return nil, err
    }

    assetID = ""
    eventBytes := []byte(args[0])
    log.Debugf("updateAsset arg: %s", args[0])

    err = json.Unmarshal(eventBytes, &event)
    if err != nil {
        log.Errorf("updateAsset failed to unmarshal arg: %s", err)
        return nil, err
    }

    if event == nil {
        err = errors.New("createAsset unmarshal arg created nil event")
        log.Error(err)
        return nil, err
    }

    argsMap, found = event.(map[string]interface{})
    if !found {
        err := errors.New("updateAsset arg is not a map shape")
        log.Error(err)
        return nil, err
    }

    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string)
        if !found || assetID == "" {
            err := errors.New("updateAsset arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }
    log.Noticef("updateAsset found assetID %s", assetID)

    found = assetIsActive(stub, assetID)
    if !found {
        // redirect to createAsset with same parameter list
        if canCreateOnUpdate(stub) {
            log.Noticef("updateAsset redirecting asset %s to createAsset", assetID)
            var newArgs = []string{args[0], "updateAsset"}
            return t.createAsset(stub, newArgs)
        }
        err = fmt.Errorf("updateAsset asset %s does not exist", assetID)
        log.Error(err)
        return nil, err
    }

    // **********************************
    // find the asset state in the ledger
    // **********************************
    log.Infof("updateAsset: retrieving asset %s state from ledger", assetID)
    assetBytes, err := stub.GetState(assetID)
    if err != nil {
        log.Errorf("updateAsset assetID %s GETSTATE failed: %s", assetID, err)
        return nil, err
    }

    // unmarshal the existing state from the ledger to theinterface
    err = json.Unmarshal(assetBytes, &ledgerBytes)
    if err != nil {
        log.Errorf("updateAsset assetID %s unmarshal failed: %s", assetID, err)
        return nil, err
    }

    // assert the existing state as a map
    ledgerMap, found = ledgerBytes.(map[string]interface{})
    if !found {
        log.Errorf("updateAsset assetID %s LEDGER state is not a map shape", assetID)
        return nil, err
    }

    // now add incoming map values to existing state to merge them
    // this contract respects the fact that updateAsset can accept a partial state
    // as the moral equivalent of one or more discrete events
    // further: this contract understands that its schema has two discrete objects
    // that are meant to be used to send events: common, and custom
    // ledger has to have common section
    stateOut := deepMerge(map[string]interface{}(argsMap),
        map[string]interface{}(ledgerMap))
    log.Debugf("updateAsset assetID %s merged state: %s", assetID, stateOut)

    // add transaction uuid and timestamp
    stateOut[TXNUUID] = stub.GetTxID()
    txnunixtime, err := stub.GetTxTimestamp()
    if err != nil {
        err = fmt.Errorf("Error getting transaction timestamp: %s", err)
        log.Error(err)
        return nil, err
    }
    txntimestamp := time.Unix(txnunixtime.Seconds, int64(txnunixtime.Nanos))
    stateOut[TXNTIMESTAMP] = txntimestamp

    // save the original event
    stateOut["lastEvent"] = make(map[string]interface{})
    stateOut["lastEvent"].(map[string]interface{})["function"] = "updateAsset"
    stateOut["lastEvent"].(map[string]interface{})["arg"] = argsMap

    // handle compliance section
    alerts := newAlertStatus()
    a, found := stateOut["alerts"] // is there an existing alert state?
    if found {
        // convert to an AlertStatus, which does not work by type assertion
        log.Debugf("updateAsset Found existing alerts state: %s", a)
        // complex types are all untyped interfaces, so require conversion to
        // the structure that is used, but not in the other direction as the
        // type is properly specified
        alerts.alertStatusFromMap(a.(map[string]interface{}))
    }
    // important: rules need access to the entire calculated state
    noncompliant, err := ledgerMap.executeRules(&alerts)
    if err != nil {
        err = fmt.Errorf("Rules engine failure: %s", err)
        log.Error(err)
        return nil, err
    }
    if noncompliant {
        // true means noncompliant
        log.Noticef("updateAsset assetID %s is noncompliant", assetID)
        // update ledger with new state, if all clear then delete
        stateOut["alerts"] = alerts
        delete(stateOut, "compliant")
    } else {
        if alerts.AllClear() {
            // all false, no need to appear
            delete(stateOut, "alerts")
        } else {
            stateOut["alerts"] = alerts
        }
        stateOut["compliant"] = true
    }

    // remove setter or command sub-events now that the incoming event is captured
    //delete(stateOut, "setter1")
    //delete(stateOut, "setter2")

    // Write the new state to the ledger
    stateJSON, err := json.Marshal(ledgerMap)
    if err != nil {
        err = fmt.Errorf("updateAsset AssetID %s marshal failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    log.Debugf("UpdateAsset: putting to state ==>%s<==", string(stateJSON))

    // finally, put the new state
    err = stub.PutState(assetID, []byte(stateJSON))
    if err != nil {
        err = fmt.Errorf("updateAsset AssetID %s PUTSTATE failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }
    err = pushRecentState(stub, string(stateJSON))
    if err != nil {
        err = fmt.Errorf("updateAsset AssetID %s push to recentstates failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    // add history state
    err = updateStateHistory(stub, assetID, string(stateJSON))
    if err != nil {
        err = fmt.Errorf("updateAsset AssetID %s push to history failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    // NOTE: Contract state is not updated by updateAsset

    return nil, nil
}

// ************************************
// deleteAsset
// ************************************
func (t *SimpleChaincode) deleteAsset(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var assetID string
    var argsMap ArgsMap
    var event interface{}
    var found bool
    var err error

    if len(args) != 1 {
        err = errors.New("Expecting one JSON state object with an assetID")
        log.Error(err)
        return nil, err
    }

    assetID = ""
    eventBytes := []byte(args[0])
    log.Debugf("deleteAsset arg: %s", args[0])

    err = json.Unmarshal(eventBytes, &event)
    if err != nil {
        log.Errorf("deleteAsset failed to unmarshal arg: %s", err)
        return nil, err
    }

    argsMap, found = event.(map[string]interface{})
    if !found {
        err := errors.New("deleteAsset arg is not a map shape")
        log.Error(err)
        return nil, err
    }

    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string)
        if !found || assetID == "" {
            err := errors.New("deleteAsset arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }

    found = assetIsActive(stub, assetID)
    if !found {
        err = fmt.Errorf("deleteAsset assetID %s does not exist", assetID)
        log.Error(err)
        return nil, err
    }

    // Delete the key / asset from the ledger
    err = stub.DelState(assetID)
    if err != nil {
        log.Errorf("deleteAsset assetID %s failed DELSTATE", assetID)
        return nil, err
    }
    // remove state history
    err = deleteStateHistory(stub, assetID)
    if err != nil {
        err := fmt.Errorf("deleteAsset asset %s state history delete failed: %s", assetID, err)
        log.Critical(err)
        return nil, err
    }
    // push the recent state
    err = removeAssetFromRecentState(stub, assetID)
    if err != nil {
        err := fmt.Errorf("deleteAsset asset %s recent state removal failed: %s", assetID, err)
        log.Critical(err)
        return nil, err
    }

    return nil, nil
}

// ************************************
// deletePropertiesFromAsset
// ************************************
func (t *SimpleChaincode) deletePropertiesFromAsset(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var assetID string
    var argsMap ArgsMap
    var event interface{}
    var ledgerMap ArgsMap
    var ledgerBytes interface{}
    var found bool
    var err error
    var alerts AlertStatus

    if len(args) < 1 {
        err = errors.New("Not enough arguments. Expecting one JSON object with mandatory AssetID and property name array")
        log.Error(err)
        return nil, err
    }
    eventBytes := []byte(args[0])

    err = json.Unmarshal(eventBytes, &event)
    if err != nil {
        log.Error("deletePropertiesFromAsset failed to unmarshal arg")
        return nil, err
    }

    argsMap, found = event.(map[string]interface{})
    if !found {
        err := errors.New("deletePropertiesFromAsset arg is not a map shape")
        log.Error(err)
        return nil, err
    }
    log.Debugf("deletePropertiesFromAsset arg: %+v", argsMap)

    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string)
        if !found || assetID == "" {
            err := errors.New("deletePropertiesFromAsset arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }

    found = assetIsActive(stub, assetID)
    if !found {
        err = fmt.Errorf("deletePropertiesFromAsset assetID %s does not exist", assetID)
        log.Error(err)
        return nil, err
    }

    // is there a list of property names?
    var qprops []interface{}
    qpropsBytes, found := getObject(argsMap, "qualPropsToDelete")
    if found {
        qprops, found = qpropsBytes.([]interface{})
        log.Debugf("deletePropertiesFromAsset qProps: %+v, Found: %+v, Type: %+v", qprops, found, reflect.TypeOf(qprops))
        if !found || len(qprops) < 1 {
            log.Errorf("deletePropertiesFromAsset asset %s qualPropsToDelete is not an array or is empty", assetID)
            return nil, err
        }
    } else {
        log.Errorf("deletePropertiesFromAsset asset %s has no qualPropsToDelete argument", assetID)
        return nil, err
    }

    // **********************************
    // find the asset state in the ledger
    // **********************************
    log.Infof("deletePropertiesFromAsset: retrieving asset %s state from ledger", assetID)
    assetBytes, err := stub.GetState(assetID)
    if err != nil {
        err = fmt.Errorf("deletePropertiesFromAsset AssetID %s GETSTATE failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    // unmarshal the existing state from the ledger to the interface
    err = json.Unmarshal(assetBytes, &ledgerBytes)
    if err != nil {
        err = fmt.Errorf("deletePropertiesFromAsset AssetID %s unmarshal failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    // assert the existing state as a map
    ledgerMap, found = ledgerBytes.(map[string]interface{})
    if !found {
        err = fmt.Errorf("deletePropertiesFromAsset AssetID %s LEDGER state is not a map shape", assetID)
        log.Error(err)
        return nil, err
    }

    // now remove properties from state, they are qualified by level
OUTERDELETELOOP:
    for p := range qprops {
        prop := qprops[p].(string)
        log.Debugf("deletePropertiesFromAsset AssetID %s deleting qualified property: %s", assetID, prop)
        // TODO Ugly, isolate in a function at some point
        if (CASESENSITIVEMODE && strings.HasSuffix(prop, ASSETID)) ||
            (!CASESENSITIVEMODE && strings.HasSuffix(strings.ToLower(prop), strings.ToLower(ASSETID))) {
            log.Warningf("deletePropertiesFromAsset AssetID %s cannot delete protected qualified property: %s", assetID, prop)
        } else {
            levels := strings.Split(prop, ".")
            lm := (map[string]interface{})(ledgerMap)
            for l := range levels {
                // lev is the name of a level
                lev := levels[l]
                if l == len(levels)-1 {
                    // we're here, delete the actual property name from this level of the map
                    levActual, found := findMatchingKey(lm, lev)
                    if !found {
                        log.Warningf("deletePropertiesFromAsset AssetID %s property match %s not found", assetID, lev)
                        continue OUTERDELETELOOP
                    }
                    log.Debugf("deletePropertiesFromAsset AssetID %s deleting %s", assetID, prop)
                    delete(lm, levActual)
                } else {
                    // navigate to the next level object
                    log.Debugf("deletePropertiesFromAsset AssetID %s navigating to level %s", assetID, lev)
                    lmBytes, found := findObjectByKey(lm, lev)
                    if found {
                        lm, found = lmBytes.(map[string]interface{})
                        if !found {
                            log.Noticef("deletePropertiesFromAsset AssetID %s level %s not found in ledger", assetID, lev)
                            continue OUTERDELETELOOP
                        }
                    }
                }
            }
        }
    }
    log.Debugf("updateAsset AssetID %s final state: %s", assetID, ledgerMap)

    // add transaction uuid and timestamp
    ledgerMap[TXNUUID] = stub.GetTxID()
    txnunixtime, err := stub.GetTxTimestamp()
    if err != nil {
        err = fmt.Errorf("Error getting transaction timestamp: %s", err)
        log.Error(err)
        return nil, err
    }
    txntimestamp := time.Unix(txnunixtime.Seconds, int64(txnunixtime.Nanos))
    ledgerMap[TXNTIMESTAMP] = txntimestamp

    // save the original event
    ledgerMap["lastEvent"] = make(map[string]interface{})
    ledgerMap["lastEvent"].(map[string]interface{})["function"] = "deletePropertiesFromAsset"
    ledgerMap["lastEvent"].(map[string]interface{})["arg"] = argsMap

    // handle compliance section
    alerts = newAlertStatus()
    a, found := ledgerMap["alerts"] // is there an existing alert state?
    if found {
        // convert to an AlertStatus, which does not work by type assertion
        log.Debugf("deletePropertiesFromAsset Found existing alerts state: %s", a)
        // complex types are all untyped interfaces, so require conversion to
        // the structure that is used, but not in the other direction as the
        // type is properly specified
        alerts.alertStatusFromMap(a.(map[string]interface{}))
    }
    // important: rules need access to the entire calculated state
    noncompliant, err := ledgerMap.executeRules(&alerts)
    if err != nil {
        err = fmt.Errorf("Rules engine failure: %s", err)
        log.Error(err)
        return nil, err
    }
    if noncompliant {
        // true means noncompliant
        log.Noticef("deletePropertiesFromAsset assetID %s is noncompliant", assetID)
        // update ledger with new state, if all clear then delete
        ledgerMap["alerts"] = alerts
        delete(ledgerMap, "compliant")
    } else {
        if alerts.AllClear() {
            // all false, no need to appear
            delete(ledgerMap, "alerts")
        } else {
            ledgerMap["alerts"] = alerts
        }
        ledgerMap["compliant"] = true
    }

    // Write the new state to the ledger
    stateJSON, err := json.Marshal(ledgerMap)
    if err != nil {
        err = fmt.Errorf("deletePropertiesFromAsset AssetID %s marshal failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    log.Debugf("DeletePropertiesFromAsset: putting to state ==>%s<==", string(stateJSON))

    // finally, put the new state
    err = stub.PutState(assetID, []byte(stateJSON))
    if err != nil {
        err = fmt.Errorf("deletePropertiesFromAsset AssetID %s PUTSTATE failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }
    err = pushRecentState(stub, string(stateJSON))
    if err != nil {
        err = fmt.Errorf("deletePropertiesFromAsset AssetID %s push to recentstates failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    // add history state
    err = updateStateHistory(stub, assetID, string(stateJSON))
    if err != nil {
        err = fmt.Errorf("deletePropertiesFromAsset AssetID %s push to history failed: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    return nil, nil
}

// ************************************
// deleteAllAssets
// ************************************
func (t *SimpleChaincode) deleteAllAssets(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    iter, err := stub.RangeQueryState("IOT", "IOT}")
    if err != nil {
        err = fmt.Errorf("deleteAllAssets failed to get a range query iterator: %s", err)
        log.Error(err)
        return nil, err
    }
    defer iter.Close()
    for iter.HasNext() {
        assetID, _, err := iter.Next()
        if err != nil {
            err = fmt.Errorf("deleteAllAssets iter.Next() failed: %s", err)
            log.Error(err)
            return nil, err
        }
        // Delete the key / asset from the ledger
        err = stub.DelState(assetID)
        if err != nil {
            log.Errorf("deleteAsset assetID %s failed DELSTATE", assetID)
            return nil, err
        }
        if strings.HasSuffix(assetID, ".StateHistory") {
            continue
        }
        // push the recent state
        err = removeAssetFromRecentState(stub, assetID)
        if err != nil {
            err := fmt.Errorf("deleteAsset asset %s recent state removal failed: %s", assetID, err)
            log.Critical(err)
            return nil, err
        }
    }
    return nil, nil
}

// ************************************
// readAsset
// ************************************
func (t *SimpleChaincode) readAsset(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var assetID string
    var argsMap ArgsMap
    var request interface{}
    var assetBytes []byte
    var found bool
    var err error

    if len(args) != 1 {
        err = errors.New("Expecting one JSON event object")
        log.Error(err)
        return nil, err
    }

    requestBytes := []byte(args[0])
    log.Debugf("readAsset arg: %s", args[0])

    err = json.Unmarshal(requestBytes, &request)
    if err != nil {
        log.Errorf("readAsset failed to unmarshal arg: %s", err)
        return nil, err
    }

    argsMap, found = request.(map[string]interface{})
    if !found {
        err := errors.New("readAsset arg is not a map shape")
        log.Error(err)
        return nil, err
    }

    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string)
        if !found || assetID == "" {
            err := errors.New("readAsset arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }

    found = assetIsActive(stub, assetID)
    if !found {
        err := fmt.Errorf("readAsset arg asset %s does not exist", assetID)
        log.Error(err)
        return nil, err
    }

    // Get the state from the ledger
    assetBytes, err = stub.GetState(assetID)
    if err != nil {
        log.Errorf("readAsset assetID %s failed GETSTATE", assetID)
        return nil, err
    }

    return assetBytes, nil
}

// ************************************
// readAllAssets
// ************************************
func (t *SimpleChaincode) readAllAssets(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var assets ByAssetID
    var err error
    var state interface{}

    iter, err := stub.RangeQueryState("IOT", "IOT}")
    if err != nil {
        err = fmt.Errorf("readAllAssets failed to get a range query iterator: %s", err)
        log.Error(err)
        return nil, err
    }
    defer iter.Close()
    for iter.HasNext() {
        assetID, assetBytes, err := iter.Next()
        if err != nil {
            err = fmt.Errorf("readAllAssets iter.Next() failed: %s", err)
            log.Error(err)
            return nil, err
        }
        if strings.HasSuffix(assetID, ".StateHistory") {
            continue
        }
        // log.Debug("readAllAssets found assetID: " + assetID + "\n")
        err = json.Unmarshal(assetBytes, &state)
        if err != nil {
            err = fmt.Errorf("readAllAssets unmarshal failed: %s", err)
            log.Error(err)
            return nil, err
        }
        assets = append(assets, AssetArr{AssetID: assetID, Asset: state})
    }

    //log.Debugf("%s: Final assets list: %+v\n", caller, assets)
    if len(assets) == 0 {
        return []byte("[]"), nil
    }

    sort.Sort(assets)

    var results []interface{}
    for _, a := range assets {
        results = append(results, a.Asset)
    }

    resultsBytes, err := json.Marshal(&results)
    if err != nil {
        err = fmt.Errorf("readAllAssets failed to marshal assets structure: %s", err)
        log.Error(err)
        return nil, err
    }
    return resultsBytes, nil
}

// ************************************
// readAssetHistory
// ************************************
func (t *SimpleChaincode) readAssetHistory(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var assetBytes []byte
    var assetID string
    var argsMap ArgsMap
    var request interface{}
    var found bool
    var err error

    if len(args) != 1 {
        err = errors.New("readAssetHistory expects a JSON encoded object with assetID and count")
        log.Error(err)
        return nil, err
    }

    requestBytes := []byte(args[0])
    log.Debugf("readAssetHistory arg: %s", args[0])

    err = json.Unmarshal(requestBytes, &request)
    if err != nil {
        err = fmt.Errorf("readAssetHistory failed to unmarshal arg: %s", err)
        log.Error(err)
        return nil, err
    }

    argsMap, found = request.(map[string]interface{})
    if !found {
        err := errors.New("readAssetHistory arg is not a map shape")
        log.Error(err)
        return nil, err
    }

    // is assetID present or blank?
    assetIDBytes, found := getObject(argsMap, ASSETID)
    if found {
        assetID, found = assetIDBytes.(string)
        if !found || assetID == "" {
            err := errors.New("readAssetHistory arg does not include assetID")
            log.Error(err)
            return nil, err
        }
    }

    found = assetIsActive(stub, assetID)
    if !found {
        err := fmt.Errorf("readAssetHistory arg asset %s does not exist", assetID)
        log.Error(err)
        return nil, err
    }

    // Get the history from the ledger
    stateHistory, err := readStateHistory(stub, assetID)
    if err != nil {
        err = fmt.Errorf("readAssetHistory assetID %s failed readStateHistory: %s", assetID, err)
        log.Error(err)
        return nil, err
    }

    // is count present?
    var olen int
    countBytes, found := getObject(argsMap, "count")
    if found {
        olen = int(countBytes.(float64))
    }
    if olen <= 0 || olen > len(stateHistory.AssetHistory) {
        olen = len(stateHistory.AssetHistory)
    }
    var hStatesOut = make([]interface{}, 0, olen)
    for i := 0; i < olen; i++ {
        var obj interface{}
        err = json.Unmarshal([]byte(stateHistory.AssetHistory[i]), &obj)
        if err != nil {
            log.Errorf("readAssetHistory JSON unmarshal of entry %d failed [%#v]", i, stateHistory.AssetHistory[i])
            return nil, err
        }
        hStatesOut = append(hStatesOut, obj)
    }
    assetBytes, err = json.Marshal(hStatesOut)
    if err != nil {
        log.Errorf("readAssetHistory failed to marshal results: %s", err)
        return nil, err
    }

    return []byte(assetBytes), nil
}

//***************************************************
//***************************************************
//* CONTRACT STATE
//***************************************************
//***************************************************

func (t *SimpleChaincode) readContractState(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var err error

    if len(args) != 0 {
        err = errors.New("Too many arguments. Expecting none.")
        log.Error(err)
        return nil, err
    }

    // Get the state from the ledger
    chaincodeBytes, err := stub.GetState(CONTRACTSTATEKEY)
    if err != nil {
        err = fmt.Errorf("readContractState failed GETSTATE: %s", err)
        log.Error(err)
        return nil, err
    }

    return chaincodeBytes, nil
}

//***************************************************
//***************************************************
//* CONTRACT METADATA / SCHEMA INTERFACE
//***************************************************
//***************************************************

// ************************************
// readAssetSamples
// ************************************
func (t *SimpleChaincode) readAssetSamples(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    return []byte(samples), nil
}

// ************************************
// readAssetSchemas
// ************************************
func (t *SimpleChaincode) readAssetSchemas(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    return []byte(schemas), nil
}

// ************************************
// readContractObjectModel
// ************************************
func (t *SimpleChaincode) readContractObjectModel(stub shim.ChaincodeStubInterface, args []string) ([]byte, error) {
    var state = ContractState{MYVERSION, DEFAULTNICKNAME}

    stateJSON, err := json.Marshal(state)
    if err != nil {
        err := fmt.Errorf("JSON Marshal failed for get contract object model empty state: %+v with error [%s]", state, err)
        log.Error(err)
        return nil, err
    }
    return stateJSON, nil
}

// ************************************
// setLoggingLevel
// ************************************
func (t *SimpleChaincode) setLoggingLevel(stub shim.ChaincodeStubInterface, args []string) error {
    type LogLevelArg struct {
        Level string `json:"logLevel"`
    }
    var level LogLevelArg
    var err error
    if len(args) != 1 {
        err = errors.New("Incorrect number of arguments. Expecting a JSON encoded LogLevel.")
        log.Error(err)
        return err
    }
    err = json.Unmarshal([]byte(args[0]), &level)
    if err != nil {
        err = fmt.Errorf("setLoggingLevel failed to unmarshal arg: %s", err)
        log.Error(err)
        return err
    }
    for i, lev := range logLevelNames {
        if strings.ToUpper(level.Level) == lev {
            (*log).SetLoggingLevel(LogLevel(i))
            return nil
        }
    }
    err = fmt.Errorf("Unknown Logging level: %s", level.Level)
    log.Error(err)
    return err
}

// CreateOnUpdate is a shared parameter structure for the use of
// the createonupdate feature
type CreateOnUpdate struct {
    CreateOnUpdate bool `json:"createOnUpdate"`
}

// ************************************
// setCreateOnUpdate
// ************************************
func (t *SimpleChaincode) setCreateOnUpdate(stub shim.ChaincodeStubInterface, args []string) error {
    var createOnUpdate CreateOnUpdate
    var err error
    if len(args) != 1 {
        err = errors.New("setCreateOnUpdate expects a single parameter")
        log.Error(err)
        return err
    }
    err = json.Unmarshal([]byte(args[0]), &createOnUpdate)
    if err != nil {
        err = fmt.Errorf("setCreateOnUpdate failed to unmarshal arg: %s", err)
        log.Error(err)
        return err
    }
    err = PUTcreateOnUpdate(stub, createOnUpdate)
    if err != nil {
        err = fmt.Errorf("setCreateOnUpdate failed to PUT setting: %s", err)
        log.Error(err)
        return err
    }
    return nil
}

// PUTcreateOnUpdate marshals the new setting and writes it to the ledger
func PUTcreateOnUpdate(stub shim.ChaincodeStubInterface, createOnUpdate CreateOnUpdate) (err error) {
    createOnUpdateBytes, err := json.Marshal(createOnUpdate)
    if err != nil {
        err = errors.New("PUTcreateOnUpdate failed to marshal")
        log.Error(err)
        return err
    }
    err = stub.PutState("CreateOnUpdate", createOnUpdateBytes)
    if err != nil {
        err = fmt.Errorf("PUTSTATE createOnUpdate failed: %s", err)
        log.Error(err)
        return err
    }
    return nil
}

// canCreateOnUpdate retrieves the setting from the ledger and returns it to the calling function
func canCreateOnUpdate(stub shim.ChaincodeStubInterface) bool {
    var createOnUpdate CreateOnUpdate
    createOnUpdateBytes, err := stub.GetState("CreateOnUpdate")
    if err != nil {
        err = fmt.Errorf("GETSTATE for canCreateOnUpdate failed: %s", err)
        log.Error(err)
        return true // true is the default
    }
    err = json.Unmarshal(createOnUpdateBytes, &createOnUpdate)
    if err != nil {
        err = fmt.Errorf("canCreateOnUpdate failed to marshal: %s", err)
        log.Error(err)
        return true // true is the default
    }
    return createOnUpdate.CreateOnUpdate
}

// new sorted list of assets taken from aviation contract

// AssetArr provides a way to gather all assets and sort them
type AssetArr struct {
    AssetID string
    Asset   interface{}
}

// ByAssetID is an array of tagged assets for sorting
type ByAssetID []AssetArr

func (a ByAssetID) Len() int           { return len(a) }
func (a ByAssetID) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByAssetID) Less(i, j int) bool { return a[i].AssetID < a[j].AssetID }
